from collections import namedtuple
from functools import partial

import corner
import matplotlib.pyplot as plt
import numpy as np
import numpyro.distributions as dist
from bilby.core.utils import ra_dec_to_theta_phi, speed_of_light, theta_phi_to_ra_dec
from bilby.gw.detector import InterferometerList
from bilby_cython.time import greenwich_mean_sidereal_time
from gpucbc.waveforms import TF2
from jax.scipy.special import erf, erfinv, i0e
from jax.random import split, PRNGKey
from jax import numpy as jnp
from numpy.random import randint
from numpyro.infer import hmc, NUTS, MCMC

gmst = greenwich_mean_sidereal_time(0.0)


def unit_normal_ln_pdf(xx: jnp.ndarray) -> jnp.ndarray:
    """Unit normal natural log probability distribution function"""
    return -(xx ** 2) / 2 - jnp.log(2 * np.pi) / 2


def unit_normal_cdf(xx: np.ndarray) -> np.ndarray:
    """Unit normal cumulative distribution function"""
    return (1 + erf(xx / 2 ** 0.5)) / 2


def unit_normal_ppf(xx: np.ndarray) -> np.ndarray:
    """Unit normal percentile point function"""
    return 2 ** 0.5 * erfinv(2 * xx - 1)


def ln_i0(value):
    return jnp.log(i0e(jnp.abs(value))) + value


def time_delay_geocentric(ra, dec):
    """
    Calculate time delay between two detectors in geocentric coordinates based on XLALArrivaTimeDiff in TimeDelay.c

    Parameters
    ==========
    detector1: array_like
        Cartesian coordinate vector for the first detector in the geocentric frame
        generated by the Interferometer class as self.vertex.
    detector2: array_like
        Cartesian coordinate vector for the second detector in the geocentric frame.
        To get time delay from Earth center, use detector2 = np.array([0,0,0])
    ra: float
        Right ascension of the source in radians
    dec: float
        Declination of the source in radians
    time: float
        GPS time in the geocentric frame

    Returns
    =======
    float: Time delay between the two detectors in the geocentric frame

    """
    np = jnp
    theta, phi = ra_dec_to_theta_phi(ra, dec, gmst)
    omega = np.array(
        [np.sin(theta) * np.cos(phi), np.sin(theta) * np.sin(phi), np.cos(theta)]
    )
    return np.dot(omega, -vertices.T) / speed_of_light


def get_polarization_tensors(ra, dec, psi):
    """
    Calculate the polarization tensor for a given sky location and time

    See Nishizawa et al. (2009) arXiv:0903.0528 for definitions of the polarisation tensors.
    [u, v, w] represent the Earth-frame
    [m, n, omega] represent the wave-frame
    Note: there is a typo in the definition of the wave-frame in Nishizawa et al.

    Parameters
    ==========
    ra: float
        right ascension in radians
    dec: float
        declination in radians
    time: float
        geocentric GPS time
    psi: float
        binary polarisation angle counter-clockwise about the direction of propagation
    mode: str
        polarisation mode

    Returns
    =======
    array_like: A 3x3 representation of the polarization_tensor for the specified mode.

    """
    np = jnp
    theta, phi = ra_dec_to_theta_phi(ra, dec, gmst)
    u = jnp.array(
        [np.cos(phi) * np.cos(theta), np.cos(theta) * np.sin(phi), -np.sin(theta)]
    )
    v = jnp.array([-np.sin(phi), np.cos(phi), 0])
    m = -u * jnp.sin(psi) - v * np.cos(psi)
    n = -u * jnp.cos(psi) + v * np.sin(psi)

    return jnp.outer(m, m) - jnp.outer(n, n), jnp.outer(m, n) + jnp.outer(n, m)


def response(dec, ra, psi, tensor):
    fp, fx = get_polarization_tensors(ra, dec, psi)
    fp = jnp.einsum("ij,ij->", tensor, fp)
    fx = jnp.einsum("ij,ij->", tensor, fx)
    return fp, fx


def project_wf(wf, cos_theta_jn, ra, dec, psi, tensor):
    hp = wf * (1 + cos_theta_jn ** 2) / 2
    hx = -1j * wf * cos_theta_jn
    fp, fx = response(dec, ra, psi, tensor)
    wf = hp * fp + hx * fx
    return wf


def morlet_gabor_wavelet(
    frequency_array,
    amplitude,
    q_factor,
    centre_frequency,
    ellipticity,
    delta_time,
    phase,
):
    """
    See equation (5) of https://arxiv.org/pdf/1410.3835.pdf

    Parameters
    ----------
    frequency_array: array-like
    amplitude: float
    q_factor: float
    centre_frequency: float
    ellipticity: float
    delta_time: float
    phase: float

    Returns
    -------
    dict: dictionary of plus and cross waveforms
    """
    tau = q_factor / (2 * np.pi * centre_frequency)
    delta_f_plus = frequency_array + centre_frequency
    delta_f_minus = frequency_array - centre_frequency

    h_plus = (
        amplitude
        * np.pi ** 0.5
        * tau
        / 2
        * jnp.exp(-np.pi ** 2 * tau ** 2 * delta_f_minus ** 2)
        * (
            jnp.exp(1j * (phase + 2 * np.pi * delta_f_minus * delta_time))
            + jnp.exp(
                -1j * (phase + 2 * np.pi * delta_f_plus * delta_time)
                - q_factor ** 2 * frequency_array / centre_frequency
            )
        )
    )
    h_cross = -1j * ellipticity * h_plus

    return {"plus": h_plus, "cross": h_cross}


def euler_rotation(delta_x):
    """
    Calculate the rotation matrix mapping the vector (0, 0, 1) to delta_x
    while preserving the origin of the azimuthal angle.

    This is decomposed into three Euler angle, alpha, beta, gamma, which rotate
    about the z-, y-, and z- axes respectively.

    Parameters
    ==========
    delta_x: array-like (3,)
        Vector onto which (0, 0, 1) should be mapped.

    Returns
    =======
    total_rotation: array-like (3,3)
        Rotation matrix which maps vectors from the frame in which delta_x is
        aligned with the z-axis to the target frame.
    """
    np = jnp

    delta_x = delta_x / np.sum(delta_x ** 2) ** 0.5
    alpha = np.arctan(-delta_x[1] * delta_x[2] / delta_x[0])
    beta = np.arccos(delta_x[2])
    gamma = np.arctan(delta_x[1] / delta_x[0])
    rotation_1 = np.array(
        [
            [np.cos(alpha), -np.sin(alpha), 0],
            [np.sin(alpha), np.cos(alpha), 0],
            [0, 0, 1],
        ]
    )
    rotation_2 = np.array(
        [[np.cos(beta), 0, -np.sin(beta)], [0, 1, 0], [np.sin(beta), 0, np.cos(beta)]]
    )
    rotation_3 = np.array(
        [
            [np.cos(gamma), -np.sin(gamma), 0],
            [np.sin(gamma), np.cos(gamma), 0],
            [0, 0, 1],
        ]
    )
    total_rotation = np.einsum("ij,jk,kl->il", rotation_3, rotation_2, rotation_1)
    return total_rotation


def zenith_azimuth_to_theta_phi(zenith, azimuth):
    """
    Convert from the 'detector frame' to the Earth frame.

    Parameters
    ==========
    kappa: float
        The zenith angle in the detector frame
    eta: float
        The azimuthal angle in the detector frame
    ifos: list
        List of Interferometer objects defining the detector frame

    Returns
    =======
    theta, phi: float
        The zenith and azimuthal angles in the earth frame.
    """
    np = jnp
    azimuth += azimuth_correction
    omega_prime = np.array(
        [
            np.sin(zenith) * np.cos(azimuth),
            np.sin(zenith) * np.sin(azimuth),
            np.cos(zenith),
        ]
    )
    omega = np.dot(rotation_matrix, omega_prime)
    theta = np.arccos(omega[2])
    phi = np.arctan2(omega[1], omega[0]) % (2 * np.pi)
    return theta, phi


def zenith_azimuth_to_ra_dec(zenith, azimuth):
    """
    Convert from the 'detector frame' to the Earth frame.

    Parameters
    ==========
    kappa: float
        The zenith angle in the detector frame
    eta: float
        The azimuthal angle in the detector frame
    geocent_time: float
        GPS time at geocenter
    ifos: list
        List of Interferometer objects defining the detector frame

    Returns
    =======
    ra, dec: float
        The zenith and azimuthal angles in the sky frame.
    """
    theta, phi = zenith_azimuth_to_theta_phi(zenith, azimuth)
    ra, dec = theta_phi_to_ra_dec(theta, phi, gmst)
    ra = ra % (2 * np.pi)
    return ra, dec


def extract_extrinsic(sample):
    delta_time = sample[-8]
    phase_x = sample[-7]
    phase_y = sample[-6]
    phase = jnp.angle(phase_x + 1j * phase_y) + np.pi
    cos_theta_jn = sample[-5]
    cos_theta_jn = unit_normal_cdf(cos_theta_jn)
    cos_zenith = sample[-4]
    azimuth = sample[-3]
    azimuth += np.pi * (cos_theta_jn < 0)
    ra, dec = zenith_azimuth_to_ra_dec(jnp.arccos(cos_zenith), azimuth)
    psi_x = sample[-2]
    psi_y = sample[-1]
    psi = (jnp.angle(psi_x + 1j * psi_y) + np.pi) / 2
    fp, fx = response(dec, ra, psi, detectors[0])
    phase += 2 * np.pi * 100 * delta_time
    phase -= jnp.angle((1 + cos_theta_jn ** 2) / 2 * fp - 1j * cos_theta_jn * fx)
    return delta_time, phase, ra, dec, psi, cos_theta_jn


def generate_burst(sample, frequencies):
    amplitude = 10 ** sample[0]
    q_factor = sample[1]
    centre_frequency = sample[2]
    _, phase, _, _, _, cos_theta_jn = extract_extrinsic(sample)
    amplitude /= abs((1 + cos_theta_jn ** 2) / 2 - 1j * cos_theta_jn)
    return morlet_gabor_wavelet(
        frequency_array=frequencies,
        amplitude=amplitude,
        q_factor=q_factor,
        centre_frequency=centre_frequency,
        delta_time=0,
        phase=phase,
        ellipticity=1,
    )["plus"]


def generate_cbc(sample, frequencies):
    q = unit_normal_cdf(sample[1])
    m1 = sample[0] * (1 + q) ** 0.2 / q ** 0.6
    m2 = m1 * q
    chi_1 = sample[2]
    chi_2 = sample[3]
    luminosity_distance = sample[4]
    waveform = TF2(m1, m2, chi_1, chi_2, 1)(frequencies) / luminosity_distance
    _, phase, _, _, _, cos_theta_jn = extract_extrinsic(sample)
    waveform /= abs((1 + cos_theta_jn ** 2) / 2 - 1j * cos_theta_jn)
    return waveform


def generate_waveform(sample, wfg, frequencies):
    delta_time, phase, ra, dec, psi, cos_theta_jn = extract_extrinsic(sample)
    waveform = wfg(sample, frequencies)
    wf = jnp.asarray(
        [
            project_wf(
                waveform,
                cos_theta_jn=cos_theta_jn,
                dec=dec,
                ra=ra,
                psi=psi,
                tensor=detector,
            )
            for detector in detectors
        ]
    )
    delays = delta_time + time_delay_geocentric(ra, dec)
    wf *= jnp.exp(-2j * np.pi * jnp.outer(delays, frequencies))
    return wf


MHState = namedtuple("MHState", ["u", "rng_key", "accept_prob", "prob", "rr"])


class MetropolisHastings(hmc.MCMCKernel):
    sample_field = "u"

    def __init__(self, potential_fn, step_size=0.1):
        self.potential_fn = potential_fn
        self.step_size = step_size

    def init(self, rng_key, num_warmup, init_params, model_args, model_kwargs):
        return MHState(init_params, rng_key, 0.0, -self.potential_fn(init_params), 0.0)

    def sample(self, state, model_args, model_kwargs):
        u, rng_key, _, _, _ = state
        rng_key, key_proposal, key_accept = split(rng_key, 3)
        u_proposal = dist.Normal(u, self.step_size).sample(key_proposal)
        accept_prob = self.potential_fn(u) - self.potential_fn(u_proposal)
        rr = jnp.log(dist.Uniform().sample(key_accept))
        u_new = u + (u_proposal - u) * (rr < accept_prob)
        return MHState(u_new, rng_key, accept_prob, -self.potential_fn(u_new), rr)


def ln_likelihood(sample, wfg, data, asd, duration):
    wf = wfg(sample) / asd
    norm = 4 / duration
    d_inner_h = norm * jnp.sum(wf * data.conj())
    h_inner_h = norm * jnp.sum(jnp.abs(wf) ** 2)
    return -h_inner_h / 2 + jnp.real(d_inner_h)


def potential(mu, prior, like):
    """

    Parameters
    ----------
    mu: array
        Parameters to evaluate the model at

    Returns
    -------
    Negative posterior probability

    """
    return jnp.nan_to_num(-(prior(mu) + like(mu)), nan=jnp.inf)


def run_sampler(start, num_warmup, num_samples, ln_prior_fn, ln_likelihood_fn):
    kernel = NUTS(
        potential_fn=partial(potential, prior=ln_prior_fn, like=ln_likelihood_fn),
        adapt_mass_matrix=True,
        dense_mass=True,
    )
    mcmc = MCMC(kernel, num_warmup=num_warmup, num_samples=num_samples)
    mcmc.run(
        PRNGKey(randint(0, 100000)), init_params=start,
    )
    return mcmc


def plot_corner(mcmc, labels):
    samples = mcmc.get_samples()
    corner.corner(np.asarray(samples), labels=labels)
    plt.savefig("corner.png")
    plt.close()


def set_data(ifos, generator, true_parameters):
    data = jnp.asarray(
        [ifo.frequency_domain_strain[ifo.frequency_mask] for ifo in ifos]
    )
    # true_parameters = jnp.array([10, 10, 70.0, 0.5, 1.5, 0.5, -0.5, 1.0, 0.3, 0.6])
    asd = jnp.asarray(
        [ifo.amplitude_spectral_density_array[ifo.frequency_mask] for ifo in ifos]
    )
    data += generator(true_parameters)
    data /= asd
    return data, asd


ifos = InterferometerList(["H1", "L1", "V1", "K1"][:2])
vertices = jnp.asarray([ifo.geometry.vertex for ifo in ifos])
delta_x = ifos[0].geometry.vertex - ifos[1].geometry.vertex
rotation_matrix = euler_rotation(delta_x)
midpoint = (ifos[0].geometry.vertex + ifos[1].geometry.vertex) / 2
temp = rotation_matrix.T @ midpoint
azimuth_correction = -jnp.arctan2(temp[0], temp[1])
detectors = [jnp.array(ifo.detector_tensor) for ifo in ifos]
